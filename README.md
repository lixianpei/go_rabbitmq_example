###### Documentation
- 学习参考文档：https://www.topgoer.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/go%E6%93%8D%E4%BD%9CRabbitMQ/RabbitMQ%E4%BB%8B%E7%BB%8D.html
- RabbitMQ实战指南 https://github.com/qs-home/LearningNotes/blob/master/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARabbitMQ%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E3%80%8B.md

###### 简单调试
- 本地搭建rabbitmq，参考文档：https://www.cnblogs.com/eddyz/p/17339961.html 推荐docker部署
- 修改 consts.go 文件中的url配置

###### rabbitmq简单使用
![img.png](img/img_002.png)
- 所有MQ产品从模型抽象来说，都是一样的过程：
- 1、消费者(consumer)订阅某个队列。
- 2、生产者(product)创建消息，然后发布到队列中(queue)，最终将消息发送到监听的消费者。
  ![img_1.png](img/img_1_001.png)

- Broker：标识消息队列服务器实体.
- Virtual Host：虚拟主机。标识一批交换机、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在链接时指定，RabbitMQ默认的vhost是 /。
- Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。
- Queue：消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。
- Banding：绑定，用于消息队列和交换机之间的关联。一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。
- Channel：信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟链接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说，建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP连接。
- Connection：网络连接，比如一个TCP连接。
- Publisher：消息的生产者，也是一个向交换器发布消息的客户端应用程序。
- Consumer：消息的消费者，表示一个从一个消息队列中取得消息的客户端应用程序。
- Message：消息，消息是不具名的，它是由消息头和消息体组成。消息体是不透明的，而消息头则是由一系列的可选属性组成，这些属性包括routing-key(路由键)、priority(优先级)、delivery-mode(消息可能需要持久性存储[消息的路由模式])等。


##### Rabbitmq模式
Rabbitmq中的所有模式从顶层理解都是同一个模型，消息发送端都是把消息发送到交换机，然后通过交换机转发到指定的队列中，消息接收端通过声明交换机和队列进行消息消费。
- simple简单模式：
  - exchangeName交换机名称：AMQP default （默认）
  - 交换机类型：direct
  - queueName队列名称：自定义
  - ![img.png](img/img.png)
  
- work工作模式：
  - exchangeName交换机名称：AMQP default （默认）
  - queueName队列名称：自定义
  - 交换机类型：direct
  - 同simple一致，只是允许多个消费者进行抢占式消息消费
  - 应用场景:红包;大项目中的资源调度(任务分配系统不需知道哪一个任务执行系统在空闲,直接将任务扔到消息队列中,空闲的系统自动争抢)
  - ![img_1.png](img/img_1.png)
  
- publish/subscribe发布订阅(共享资源)模式：
  - 当消息发送到交换机时，交换机会根据预定义的路由规则将消息路由到一个或多个与之绑定的队列中。这些队列可以由不同的消费者订阅，以便处理消息。这种方式允许消息被广播到多个队列中，从而实现发布/订阅模式的特性。
  - exchangeName交换机名称：AMQP default （默认）
  - 交换机类型：fanout （扇形展开模式，意味着绑定了这个交换机的消息队列均能收到从这个交换机中发出的消息）
  - queueName队列名称：可以不指定（每次重启消费队列均会自动生成新的名称），消费端在声明交换机时交换机名称与发送端一致就能收到从交换机中发送的最新数据；同时也允许指定消费队列名称，这样下次重启后还能消费历史的消息（当使用发布订阅模式时不建议设置队列名称，违背理念）
  - 相关场景:邮件群发,群聊天,广播(广告)
  - 尝试创建消费队列时可能存在的配置情况：
    - queueName=""+autoDelete=true：队列名称随机生成，消费者退出消费后，再次启动队列就会删除，每次消费都是最新的消息
    - queueName="指定队列名称"+autoDelete=false：当消费者重启后还能消费在断开连接期间未消费的消息，
    - queueName 若队列名称使用了其他模式，比如simple或work模式创建的队列名，那么当subscribe订阅模式的消费者启动后就会把当前交换机exchange与队列进行了绑定，subscribe消费者依然能够消费simple或work模式下已经存在的消息
    - queueName := "BuyVip003" // uuid.New().String()
  - rabbitmq发布订阅模式实际的消息是会存在多个消息队列queue里面吗？
    - 答案：
    - 在RabbitMQ的发布/订阅模式中，消息确实可以存在多个消息队列中。
    - 这种模式允许一个发布者将消息发送到一个交换机（exchange），然后交换机将消息路由到绑定到它的多个队列中。
    - 每个订阅者都可以有自己的队列，并且可以绑定到交换机以接收特定类型的消息。

    - ![img_2.png](img/img_2.png)

- routing路由模式
  - exchangeName交换机名称：手动指定
  - queueName队列名称：无需指定
  - 交换机类型：direct
  - 消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息;
  - ![img_3.png](img/img_3.png)
  
- topic 主题模式(路由模式的一种)
  - exchangeName交换机名称：手动指定
  - queueName队列名称：无需指定
  - 交换机类型：direct
  - 星号井号代表通配符
  - 星号代表多个单词,井号代表一个单词
  - 路由功能添加模糊匹配
  - 消息产生者产生消息,把消息交给交换机
  - 交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费
  -![img_4.png](img/img_4.png)

##### 交换机类型 exchange.kind
- fanout【展开、广播】：把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中
- direct【直接、指定】：把消息路由到那些BindingKey和RountingKey 完全匹配的队列中
- topic【主题、满足一定规则】:将消息路由到BindingKey和RountingKey 相匹配的队列中，匹配规则约定：
- RountingKey 和 BindingKey 均为一个点“.”分隔得字符串，被点号分隔得每一段独立的字符串称为一个单词。
- BindingKey 中可以存在两种特殊的字符串“#”和“*”，其中“*”用于匹配一个单词，“#”用于匹配零个或者多个单词。
- headers类型的交换器不依赖路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。（不常用）

##### RabbitMQ运转流程

###### 生产者发送消息过程：
- 生产者连接到RabbitMQ Broker, 建立一个连接（Connection）, 开启一个信道（Channel）；
- 生产者声明一个交换器，并设置相关属性；
- 生产者声明一个队列并设置相关属性；
- 生产者通过路由键将交换器与队列绑定起来；
- 生产者发送消息至RabbitMQ Broker ，其中包含路由键、交换器等信息；
- 相应的交换器根据接收到的路由键查找相应的匹配队列；
- 如果找到，则将从生产者发送过来的消息存入相应的队列中；
- 如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者；
- 关闭信道；
- 关闭连接。


###### 消费者接收消息的过程：
- 消费者连接到RabbitMQ Broker, 建立一个连接（Connection）, 开启一个信道（Channel）；
- 消费者向RabbitMQ Broker请求消费相应队列中的消息，可能会设置相应的回调函数；
- 等待RabbitMQ Broker回应并投递相应对列中的消息，消费者接收消息；
- 消费者确认（ack）接收到的消息；
- RabbitMQ从队列中删除相应已经被确认的消息；
- 关闭信道；
- 关闭连接。


###### queueBind方法
- 用于交换器与队列的绑定
- 只要交换机与队列绑定成功，那所有声明QueueDeclare队列的消费均能处理队列中的消息（只有一个会处理成功）

######  exchangeBind方法详解
- 用于交换器与交换器的绑定


###### 参数配置说明
- exclusive : 设置是否排他。为 true 则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点:
  - 排他队列是基于连接( Connection) 可见的，同一个连接的不同信道 (Channel)是可以同时访问同一连接创建的排他队列;
  - "首次"是指如果一个连接己经声明了 一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；
  - 即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。
- autoDelete：是否自动删除，自删除的前提是至少有一个队列或者交换器与这交换器绑定,之后所有与这个交换器绑定的队列或者交换器都与此解绑后删除,一般都设置为false
